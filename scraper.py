#!/usr/bin/env python

"""Scrapes information from US-CERT and parses it into a formatted list of
   HIGH and MEDIUM vulnerabilities
"""


import argparse
from lxml import html
import re
import requests
import os.path
import sys

__author__ = "Peter Mosmans"
__copyright__ = "Copyright 2015, Go Forward"
__license__ = "GPL"
__version__ = "0.0.1"
__maintainer__ = "Peter Mosmans"
__contact__ = "support@go-forward.net"
__status__ = "Development"

default_year = 15
default_number = 5
base_url = 'https://www.us-cert.gov/ncas/bulletins/'
force = False
latest = False
verbose = False


class Vulnerability:
    """Encapsulates vulnerability"""

    def __init__(self, vendor, product, description, published, cvss,
                 cvss_score, source_info):
        self.vendor = vendor
        self.product = product
        self.description = description
        self.published = published
        self.cvss = cvss
        self.cvss_score = cvss_score
        self.source_info = source_info

    def sortname(self):
        # return 10 minus cvss_score
        score_rev = 10 - float(self.cvss_score)
        return '{0}{1}{2}'.format(self.vendor.lower(), self.product.lower(),
                                  score_rev)


def retrieve_bulletin(filename, base_url, bulletin_name):
    """Return bulletin either by HTTP or by file as tree, or empty object
    if bulletin couldn't be read
    """
    result = False
    url = '{0}{1}'.format(base_url, bulletin_name)
    if (force or not os.path.isfile(filename)):
        if verbose:
            print 'downloading {0}...'.format(url)
        page = requests.get(url)
        if page.status_code == 200:
            tree = html.fromstring(page.text)
            result = check_title(tree)
            if result:
                with open(filename, 'w') as f:
                    f.write(page.text.encode('utf-8'))
    else:
        if verbose:
            print 'reading {0} from disk...'.format(filename)
        with open(filename, 'r') as f:
            tree = html.fromstring(f.read())
            result = check_title(tree)
    if result:
        return tree
    else:
        return None


def append_vulnerabilities(tree, vuln_type, vuln_list):
    """Append vulnerability from tree of vuln_type to vuln_list"""
    vulns = tree.xpath('//table[@summary="{0}"]/tbody/tr'.format(vuln_type))
    for vuln in vulns:
        vendor = vuln[0].text.split(' -- ')[0]
        product = vuln[0].text.split(' -- ')[1]
        description = vuln[1].text
        published = vuln[2].text
        cvss = vuln[4][0].text
        cvss_score = vuln[3][0].text
        source_info = vuln[4][0].text
        vuln_list.append(Vulnerability(vendor, product, description, published,
                                       cvss, cvss_score, source_info))


def check_title(tree):
    title = tree.xpath('//title/text()')[0].split(' | ')[0].replace('[\'', '')
    if verbose:
        print '{0}'.format(title)
    response = re.search('^Vulnerability Summary', title)
    return response


def parse_arguments():
    """ Parses command line arguments, exits on invalid values """
    global cache
    global force
    global latest
    global next_bulletin
    global number
    global verbose
    global year
    parser = argparse.ArgumentParser()
    parser.add_argument('-c', '--cache', default='',
                        help='name of cache directory')
    parser.add_argument('-n', '--number', default=default_number,
                        help='specify a bulletin number to fetch')
    parser.add_argument('--year', default=default_year,
                        help='specify a bulletin year')
    parser.add_argument('-f', '--force', action='store_true',
                        help='force download')
    parser.add_argument('latest', action='store_true',
                        help='retrieve latest bulletin')
    parser.add_argument('--next', action='store_true',
                        help='retrieve the next valid bulletin')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='increase output verbosity')
    args = parser.parse_args()
    verbose = args.verbose
    force = args.force
    next_bulletin = args.next
    latest = args.latest
    try:
        year = int(args.year)
        number = int(args.number)
    except:
        print 'Error: Expecting a numeric value'
        sys.exit()
    cache = args.cache
    if cache:
        if not os.path.exists(cache):
            if verbose:
                print 'creating {0}'.format(cache)
            os.makedirs(cache)


def show_vulnerabilities(vuln_list):
    """Return a nicely formatted string of vulnerabilities from vuln_list"""
    for vuln in vuln_list:
        print '|{0}, {1}|{2}|{3}|{4}|{5}|'.format(vuln.vendor, vuln.product,
                                                  vuln.description,
                                                  vuln.published,
                                                  vuln.cvss_score, vuln.cvss)


def main():
    shift = 0
    parse_arguments()
    result = False
    vulnerabilities = []
    while not result and (shift < 7):
        bulletin_name = 'SB{0:0>2d}-{1:0>3d}'.format(year, (number + shift))
        filename = '{0}{1}.html'.format(cache, bulletin_name)
        tree = retrieve_bulletin(filename, base_url, bulletin_name)
        result = (tree is not None)
        if not result:
            print '{0}{1} doesn\'t look like a valid vulnerability summary'. \
                format(base_url, bulletin_name)
        if next_bulletin:
            shift += 1
        else:
            shift = 7
    if result:
        append_vulnerabilities(tree, 'High Vulnerabilities', vulnerabilities)
        append_vulnerabilities(tree, 'Medium Vulnerabilities', vulnerabilities)
        vulnerabilities = sorted(vulnerabilities, key=lambda x: x.sortname())
        show_vulnerabilities(vulnerabilities)
    else:
        print 'could not find any valid bulletin'. \
            format(7)

if __name__ == "__main__":
    main()
