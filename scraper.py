#!/usr/bin/env python

"""
Scrapes information from US-CERT and parses it into a formatted list of
HIGH and MEDIUM vulnerabilities

Copyright (C) 2015 Peter Mosmans [Go Forward]
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
"""

from __future__ import absolute_import
from __future__ import print_function

import argparse
from datetime import date, timedelta
import os.path
import re
import sys
import textwrap

from lxml import html
import requests


__author__ = "Peter Mosmans"
__copyright__ = "Copyright 2015, Go Forward"
__license__ = "GPLv3"
__version__ = "0.0.1"
__maintainer__ = "Peter Mosmans"
__contact__ = "support@go-forward.net"
__status__ = "Development"


BASE_URL = 'https://www.us-cert.gov/ncas/bulletins/'


class Vulnerability(object):
    """
    Encapsulates vulnerability.
    """

    def __init__(self, vendor, product, description, published, cvss,
                 cvss_score, source_info):
        self.vendor = vendor
        self.product = product
        self.description = description
        self.published = published
        self.cvss = cvss
        self.cvss_score = cvss_score
        self.source_info = source_info

    def sortname(self):
        # return 10 minus cvss_score
        score_rev = 10 - float(self.cvss_score)
        return '{0}{1}{2}'.format(self.vendor.lower(), self.product.lower(),
                                  score_rev)


def print_exit(text, result):
    """
    Prints error message to stderr and exits with result code.
    """
    print(text, file=sys.stderr)
    sys.exit(result)


def get_bulletin_name(date=date.today()):
    """
    Return correct filename of a bulletin for a given date,
    which is published each Monday.
    """
    while date.weekday():
        date = date - timedelta(days=1)
    return 'SB{0:%y}-{1:%j}'.format(date, date)


def get_bulletin_list(from_date=date.today(), to_date=date.today()):
    """
    Return a list of all filenames of bulletins to retrieve.
    """
    bulletin_list = []
    verboseprint('creating list of filenames from {0} to {1}'.
                 format(from_date, to_date))
    while from_date <= to_date:
        bulletin_list.append(get_bulletin_name(from_date))
        from_date += timedelta(weeks=1)
    return bulletin_list


def retrieve_bulletin(filename, bulletin_name, options):
    """
    Return bulletin (either by HTTP or by file) as tree, or empty object
    if a bulletin couldn't be read.
    """
    tree = None
    date_string = False
    url = '{0}{1}'.format(BASE_URL, bulletin_name)
    try:
        if options['force'] or not os.path.isfile(filename):
            verboseprint('trying to download {0}'.format(url))
            page = requests.get(url)
            if page.status_code == 200:
                tree = html.fromstring(page.text)
                date_string = check_title(tree)
                if date_string:
                    with open(filename, 'w') as html_page:
                        html_page.write(page.text.encode('utf-8'))
            else:
                verboseprint('Hmmm... received status code {0}'.format(page.status_code))
        else:
            verboseprint('reading {0} from disk'.format(filename))
            with open(filename, 'r') as html_page:
                tree = html.fromstring(html_page.read())
                date_string = check_title(tree)
        if not date_string:
            return None
        if options['query']:
            if options['query'] in date_string:
                print('DATE: ' + date_string)
                return tree
            else:
                return None
        else:
            return tree
    except requests.exceptions.ConnectionError as exception:
        print_exit('[-] Error connecting to website ({0})'.format(exception.strerror),
                   exception.errno)


def append_vulnerabilities(tree, vuln_type, vuln_list):
    """
    Append vulnerability from tree of vuln_type to vuln_list.
    """
    verboseprint('Adding {0} vulnerabilities'.format(vuln_type))
    vulns = tree.xpath('//table[@summary="{0} Vulnerabilities"]/tbody/tr'.
                       format(vuln_type))
    for vuln in vulns:
        vendor = ''
        product = ''
        if vuln[0].text:
            if '--' in vuln[0].text:
                vendor = vuln[0].text.split(' -- ')[0]
                product = vuln[0].text.split(' -- ')[1]
            else:
                vendor = vuln[0].text
        description = vuln[1].text
        published = vuln[2].text
        cvss = vuln[4][0].text
        if vuln[4].text:
            cvss_score = vuln[3][0].text
        else:
            cvss_score = 0
        source_info = vuln[4][0].text
        vuln_list.append(Vulnerability(vendor, product, description, published,
                                       cvss, cvss_score, source_info))


def check_title(tree):
    """
    Check whether the tree contains a vulnerability summary.
    Returns the date in American string format
    """
    title = tree.findtext('.//title').split(' | ')[0].replace('[\'', '')
    verboseprint(title)
    response = re.search('Vulnerability Summary for the Week of (\w+\s[0-9]{1,2}\,\s[0-9]{4})', title)
    if response and response.groups > 1:
        verboseprint('date: {0}'.format(response.group(1)))
        return response.group(1)
    else:
        return False


def parse_arguments():
    """
    Parses command line arguments, exits on invalid values.
    """
    global verboseprint
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=textwrap.dedent('''\
Downloads and parses vulnerability summaries from the US-CERT website

Copyright (C) 2015 Peter Mosmans [Go Forward]
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.'''))
    parser.add_argument('-a', '--all', action='store_true',
                        help='retrieve all missing bulletin since 2010 (!)')
    parser.add_argument('-b', '--bulletin', action='store', type=str,
                        help='retrieve a specific bulletin')
    parser.add_argument('-c', '--cache', default='cache',
                        help='name of cache directory')
    parser.add_argument('-f', '--force', action='store_true',
                        help='force download, ignore / overwrite cache')
    parser.add_argument('-l', '--low', action='store_true',
                        help='select low vulnerabilities as well')
    parser.add_argument('--quiet', action='store_true',
                        help='don\'t output parsed bulletin')
    parser.add_argument('--query', action='store',
                        help='specify a query for the title')
    parser.add_argument('--update', action='store_true',
                        help='retrieve all newest bulletin since last update')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='increase output verbosity')
    parser.add_argument('--year', action='store', nargs='?', default=0,
                        type=int,
                        help='retrieve all bulletins for a given year year')
    args = parser.parse_args()
    if args.verbose:
        def verboseprint(*args):
            print('# ', end='')
            for arg in args:
                print(arg, end='')
                print()
    else:
        verboseprint = lambda *a: None
    if args.cache:
        if not args.cache.endswith(os.path.sep):
            args.cache += os.path.sep
        if not os.path.exists(args.cache):
            verboseprint('creating {0}'.format(args.cache))
            os.makedirs(args.cache)
    options = vars(args)
    options['from_date'] = None
    options['to_date'] = date.today()
    options['selection'] = ['High', 'Medium']
    if (args.year is None) or (args.update):
        options['from_date'] = date(date.today().year, 1, 1)
    else:
        if args.year >= 2010 and args.year <= date.today().year:
            options['from_date'] = date(args.year, 1, 1)
            options['to_date'] = date(args.year, 12, 31)
    if args.all:
        options['from_date'] = date(2010, 1, 1)
    if options['from_date'] is None:
        options['from_date'] = options['to_date']
    if args.low:
        options['selection'].append('Low')
    return vars(args)


def show_vulnerabilities(vuln_list):
    """Return a nicely formatted string of vulnerabilities from vuln_list"""
    for vuln in vuln_list:
        print('|{0}, {1}|{2}|{3}|{4}|{5}|'.format(vuln.vendor, vuln.product,
                                                  vuln.description,
                                                  vuln.published,
                                                  vuln.cvss_score, vuln.cvss))


def main():
    """
    The main loop.
    """
    options = parse_arguments()
    vulnerabilities = []
    for bulletin_name in get_bulletin_list(options['from_date'], options['to_date']):
        if options['bulletin']:
            bulletin_name = options['bulletin']
        filename = '{0}{1}.html'.format(options['cache'], bulletin_name)
        tree = retrieve_bulletin(filename, bulletin_name, options)
        if tree is not None and not options['quiet']:
            for vuln_type in options['selection']:
                append_vulnerabilities(tree, vuln_type, vulnerabilities)
            vulnerabilities = sorted(vulnerabilities,
                                         key=lambda x: x.sortname())
            show_vulnerabilities(vulnerabilities)
            sys.stdout.flush()


if __name__ == "__main__":
    main()
