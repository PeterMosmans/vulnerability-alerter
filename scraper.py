#!/usr/bin/env python

"""Scrapes information from US-CERT and parses it into a formatted list of
   HIGH and MEDIUM vulnerabilities
"""


import argparse
from datetime import date
from datetime import timedelta
from lxml import html
import os.path
import re
import requests
import sys


__author__ = "Peter Mosmans"
__copyright__ = "Copyright 2015, Go Forward"
__license__ = "GPL"
__version__ = "0.0.1"
__maintainer__ = "Peter Mosmans"
__contact__ = "support@go-forward.net"
__status__ = "Development"

#default_year = 15
#default_number = 5
base_url = 'https://www.us-cert.gov/ncas/bulletins/'
force = False
latest = False
verbose = False


class Vulnerability:
    """Encapsulates vulnerability"""

    def __init__(self, vendor, product, description, published, cvss,
                 cvss_score, source_info):
        self.vendor = vendor
        self.product = product
        self.description = description
        self.published = published
        self.cvss = cvss
        self.cvss_score = cvss_score
        self.source_info = source_info

    def sortname(self):
        # return 10 minus cvss_score
        score_rev = 10 - float(self.cvss_score)
        return '{0}{1}{2}'.format(self.vendor.lower(), self.product.lower(),
                                  score_rev)


def current_bulletin_number(date=date.today()):
    """ Return filename for the most current bulletin, which is published each Monday
    Bulletins are numbered according to their 'yearly' day number.
    """
    while (date.weekday() != 0):
        date = date - timedelta(days=1)
    return 'SB{0:%y}-{1:%j}'.format(date, date)


def previous_bulletin_number(date=date.today()):
    """ Return filename for the last published bulletin, which is published each Monday
    """
    return current_bulletin_number(date - timedelta(days=1))


def retrieve_bulletin(filename, base_url, bulletin_name):
    """Return bulletin either by HTTP or by file as tree, or empty object
    if bulletin couldn't be read
    """
    result = False
    url = '{0}{1}'.format(base_url, bulletin_name)
    if (force or not os.path.isfile(filename)):
        if verbose:
            print 'downloading {0}...'.format(url)
        page = requests.get(url)
        if page.status_code == 200:
            tree = html.fromstring(page.text)
            result = check_title(tree)
            if result:
                with open(filename, 'w') as f:
                    f.write(page.text.encode('utf-8'))
    else:
        if verbose:
            print 'reading {0} from disk...'.format(filename)
        with open(filename, 'r') as f:
            tree = html.fromstring(f.read())
            result = check_title(tree)
    if result:
        return tree
    else:
        return None


def append_vulnerabilities(tree, vuln_type, vuln_list):
    """Append vulnerability from tree of vuln_type to vuln_list"""
    vulns = tree.xpath('//table[@summary="{0}"]/tbody/tr'.format(vuln_type))
    for vuln in vulns:
        vendor = vuln[0].text.split(' -- ')[0]
        product = vuln[0].text.split(' -- ')[1]
        description = vuln[1].text
        published = vuln[2].text
        cvss = vuln[4][0].text
        cvss_score = vuln[3][0].text
        source_info = vuln[4][0].text
        vuln_list.append(Vulnerability(vendor, product, description, published,
                                       cvss, cvss_score, source_info))


def check_title(tree):
    title = tree.xpath('//title/text()')[0].split(' | ')[0].replace('[\'', '')
    if verbose:
        print '{0}'.format(title)
    response = re.search('^Vulnerability Summary', title)
    return response


def parse_arguments():
    """ Parses command line arguments, exits on invalid values """
    global cache
    global force
    global latest
    global date
    date = date.today()
    global date_range
    date_range = []
    global next_bulletin
    global number
    global verbose
    global year
    parser = argparse.ArgumentParser()
    parser.add_argument('-c', '--cache', default='cache',
                        help='name of cache directory')
    parser.add_argument('-p', '--previous', action='store_true',
                        help='try to retrieve previous bulletin')
    parser.add_argument('-f', '--force', action='store_true',
                        help='force download, ignore cache')
    parser.add_argument('--update', action='store_true',
                        help='retrieve all newest bulletin since last update')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='increase output verbosity')
    args = parser.parse_args()
    verbose = args.verbose
    if (args.previous):
        date = date.today() - timedelta(weeks=1)
    force = args.force
    cache = args.cache
    if cache:
        if not cache.endswith(os.path.sep):
            cache += os.path.sep
        if not os.path.exists(cache):
            if verbose:
                print 'creating {0}'.format(cache)
            os.makedirs(cache)


def show_vulnerabilities(vuln_list):
    """Return a nicely formatted string of vulnerabilities from vuln_list"""
    for vuln in vuln_list:
        print '|{0}, {1}|{2}|{3}|{4}|{5}|'.format(vuln.vendor, vuln.product,
                                                  vuln.description,
                                                  vuln.published,
                                                  vuln.cvss_score, vuln.cvss)


def main():
    parse_arguments()
    vulnerabilities = []
    for bulletin_name in [current_bulletin_number(date), previous_bulletin_number(date)]:
        filename = '{0}{1}.html'.format(cache, bulletin_name)
        tree = retrieve_bulletin(filename, base_url, bulletin_name)
        if not (tree is None):
            break
    if not (tree is None):
        append_vulnerabilities(tree, 'High Vulnerabilities', vulnerabilities)
        append_vulnerabilities(tree, 'Medium Vulnerabilities', vulnerabilities)
        vulnerabilities = sorted(vulnerabilities, key=lambda x: x.sortname())
        show_vulnerabilities(vulnerabilities)


if __name__ == "__main__":
    main()
