#!/usr/bin/env python

"""
Scrapes information from US-CERT and parses it into a formatted list of
HIGH and MEDIUM vulnerabilities

Copyright (C) 2015-2017 Peter Mosmans [Go Forward]
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
"""

from __future__ import absolute_import
from __future__ import print_function

import argparse
from datetime import date, datetime, timedelta
import logging
import os.path
import re
import sys
import textwrap

try:
    from lxml import html
    import requests
except ImportError as exception:
    print('[-] This script needs the lxml and requests library',
          file=sys.stderr)
    print("Install lxml with: sudo pip install lxml", file=sys.stderr)
    print("Install requests with: sudo pip install requests", file=sys.stderr)
    sys.exit(-1)

__author__ = "Peter Mosmans"
__copyright__ = "Copyright 2015-2017, Go Forward"
__license__ = "GPLv3"
__version__ = "0.0.4"
__maintainer__ = "Peter Mosmans"
__contact__ = "support@go-forward.net"
__status__ = "Development"


BASE_URL = 'https://www.us-cert.gov/ncas/bulletins/'


class Vulnerability(object):
    """
    Encapsulate vulnerability.
    """

    def __init__(self, vendor, product, description, published, cvss,
                 cvss_score, source_info):
        self.vendor = vendor
        self.product = product
        self.description = description
        self.published = published
        self.cvss = cvss
        self.cvss_score = cvss_score
        self.source_info = source_info

    def sortname(self):
        """
        Sort vulnerabilities based on CVSS score.
        """
        # return 10 minus cvss_score
        score_rev = 10 - float(self.cvss_score)
        return '{0}{1}{2}'.format(self.vendor.lower(), self.product.lower(),
                                  score_rev)


def get_bulletin_name(date_object=date.today()):
    """
    Return correct filename of a bulletin for a given date,
    which is published each Monday.
    """
    while date_object.weekday():
        date_object = date_object - timedelta(days=1)
    return 'SB{0:%y}-{1:%j}'.format(date_object, date_object)


def get_bulletin_list(options):
    """
    Return a list of all filenames of bulletins to retrieve.
    """
    bulletin_list = []
    from_date = options['from_date']
    logging.debug('Creating list of filenames from %s to %s', from_date,
                  options['to_date'])
    while from_date <= (options['to_date'] + timedelta(days=2)):
        bulletin_list.append(get_bulletin_name(from_date))
        from_date += timedelta(weeks=1)
    logging.debug('Created the following names: %s', bulletin_list)
    return bulletin_list


def retrieve_bulletin(filename, bulletin_name, options):
    """
    Return bulletin (either by HTTP or by file) as tree, or empty object
    if a bulletin couldn't be read.
    """
    tree = None
    url = '{0}{1}'.format(BASE_URL, bulletin_name)
    try:
        if options['force'] or not os.path.isfile(filename):
            logging.debug('Trying to download ' + url)
            page = requests.get(url)
            if page.status_code == 200:
                tree = html.fromstring(page.text)
                if check_title(tree):
                    with open(filename, 'w') as html_page:
                        html_page.write(page.text.encode('utf-8'))
            else:
                logging.debug('Received status code %s', page.status_code)
        else:
            logging.debug('Reading %s from disk', filename)
            with open(filename, 'r') as html_page:
                tree = html.fromstring(html_page.read())
        date_object = check_title(tree)
        if date_object and date_object >= options['from_date']:
            return tree
        else:
            return None
    except requests.exceptions.ConnectionError as exception:
        logging.error('Error connecting to website (%s)', exception.strerror)
        sys.exit(exception.errno)


def append_vulnerabilities(tree, vuln_type, vuln_list):
    """
    Append vulnerability from tree of vuln_type to vuln_list.
    """
    logging.debug('Adding %s vulnerabilities', vuln_type)
    for vuln in tree.xpath('//table[@summary="{0} Vulnerabilities"]/tbody/tr'.
                           format(vuln_type)):
        vendor = ''
        product = ''
        if vuln[0].text:
            try:
                vendor, product = vuln[0].text.split(' -- ')
            except ValueError:
                vendor = vuln[0].text
        description = vuln[1].text
        published = vuln[2].text
        cvss = vuln[4][0].text
        try:
            cvss_score = vuln[3][0].text
        except IndexError:
            cvss_score = '0'
        source_info = vuln[4][0].text
        vuln_list.append(Vulnerability(vendor, product, description, published,
                                       cvss, cvss_score, source_info))


def check_title(tree):
    """
    Check whether the tree contains a vulnerability summary.
    Returns a date object if successful.
    """
    try:
        title = tree.findtext('.//title').split(' | ')[0].replace('[\'', '')
    except AttributeError:
        title = ''
    response = re.search(r'Vulnerability Summary for the Week of (\w+\s[0-9]{1,2}\,\s[0-9]{4})',
                         title)
    if response and response.groups > 1:
        date_object = datetime.strptime(response.group(1), '%B %d, %Y')
        logging.debug('Read date: %s', date_object)
        return date_object.date()
    else:
        return False


def parse_arguments():
    """
    Parses command line arguments, exits on invalid values.
    """
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=textwrap.dedent('''\
Downloads and parses vulnerability summaries from the US-CERT website

Copyright (C) 2015-2016 Peter Mosmans [Go Forward]
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.'''))
    parser.add_argument('-a', '--all', action='store_true',
                        help='retrieve all missing bulletin since 2010 (!)')
    parser.add_argument('-b', '--bulletin', action='store', type=str,
                        help='retrieve a specific bulletin')
    parser.add_argument('-c', '--cache', default='cache',
                        help='name of cache directory')
    parser.add_argument('-f', '--force', action='store_true',
                        help='force download, ignore / overwrite cache')
    parser.add_argument('--from-date', action='store',
                        help='starting date (dd-mm-YYYY)')
    parser.add_argument('-l', '--low', action='store_true',
                        help='select low vulnerabilities as well')
    parser.add_argument('--quiet', action='store_true',
                        help='don\'t output parsed bulletin')
    parser.add_argument('--query', action='store',
                        help='specify a query for the title')
    parser.add_argument('--update', action='store_true',
                        help='retrieve all newest bulletin since last update')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='increase output verbosity')
    parser.add_argument('--year', action='store', nargs='?', default=0,
                        type=int,
                        help='retrieve all bulletins for a given year year')
    return vars(parser.parse_args())


def preflight_checks(options):
    """
    Prepare everything for a smooth ride.
    """
    if not options['cache'].endswith(os.path.sep):
        options['cache'] += os.path.sep
    if not os.path.exists(options['cache']):
        logging.debug('Creating %s', options['cache'])
        os.makedirs(options['cache'])
    try:
        if options['from_date']:
            options['from_date'] = datetime.strptime(options['from_date'],
                                                     '%d-%m-%Y').date()
    except ValueError:
        logging.error('Dates must be in the form dd-mm-YYYY')
        sys.exit(-1)
    options['to_date'] = date.today()
    options['selection'] = ['High', 'Medium']
    if not options['from_date'] and ('year' not in options or (options['update'])):
        options['from_date'] = date(date.today().year, 1, 1)
    else:
        if options['year'] >= 2010 and options['year'] <= date.today().year:
            options['from_date'] = date(options['year'], 1, 1)
            options['to_date'] = date(options['year'], 12, 31)
    if options['all']:
        options['from_date'] = date(2010, 1, 1)
    if options['from_date'] is None:
        options['from_date'] = options['to_date']
    if options['low']:
        options['selection'].append('Low')
    return options


def setup_logging(options):
    """
    Set up loghandlers according to options.
    """
    # DEBUG = verbose status messages
    # INFO = status messages and logfiles
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)
    console = logging.StreamHandler(stream=sys.stdout)
    console.setFormatter(logging.Formatter('%(asctime)s %(message)s',
                                           datefmt='%H:%M:%S'))
    if options['verbose']:
        console.setLevel(logging.DEBUG)
    else:
        console.setLevel(logging.INFO)
    logger.addHandler(console)
    # make sure requests library is, erm, less verbose
    logging.getLogger('requests.packages.urllib3.connectionpool').setLevel(logging.ERROR)


def show_vulnerabilities(vuln_list):
    """Return a nicely formatted string of vulnerabilities from vuln_list"""
    for vuln in vuln_list:
        print('|{0}, {1}|{2}|{3}|{4}|{5}|'.format(vuln.vendor, vuln.product,
                                                  vuln.description,
                                                  vuln.published,
                                                  vuln.cvss_score, vuln.cvss))


def main():
    """
    The main loop.
    """
    options = parse_arguments()
    setup_logging(options)
    preflight_checks(options)
    vulnerabilities = []
    for bulletin_name in get_bulletin_list(options):
        if options['bulletin']:
            bulletin_name = options['bulletin']
        filename = '{0}{1}.html'.format(options['cache'], bulletin_name)
        tree = retrieve_bulletin(filename, bulletin_name, options)
        if tree is not None and not options['quiet']:
            for vuln_type in options['selection']:
                append_vulnerabilities(tree, vuln_type, vulnerabilities)
    vulnerabilities = sorted(vulnerabilities,
                             key=lambda x: x.sortname())
    show_vulnerabilities(vulnerabilities)
    sys.stdout.flush()


if __name__ == "__main__":
    main()
