#!/usr/bin/env python

"""
Scrapes information from US-CERT and parses it into a formatted list of
HIGH and MEDIUM vulnerabilities

Copyright (C) 2015 Peter Mosmans [Go Forward]
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
"""

from __future__ import absolute_import
from __future__ import print_function

import argparse
from datetime import date, timedelta
from lxml import html
import os.path
import re
import requests
import textwrap
import sys


__author__ = "Peter Mosmans"
__copyright__ = "Copyright 2015, Go Forward"
__license__ = "GPLv3"
__version__ = "0.0.1"
__maintainer__ = "Peter Mosmans"
__contact__ = "support@go-forward.net"
__status__ = "Development"


base_url = 'https://www.us-cert.gov/ncas/bulletins/'
cache = 'cache'
force = False
latest = False
quiet = False
selection = ['High', 'Medium']


class Vulnerability(object):
    """
    Encapsulates vulnerability.
    """

    def __init__(self, vendor, product, description, published, cvss,
                 cvss_score, source_info):
        self.vendor = vendor
        self.product = product
        self.description = description
        self.published = published
        self.cvss = cvss
        self.cvss_score = cvss_score
        self.source_info = source_info

    def sortname(self):
        # return 10 minus cvss_score
        score_rev = 10 - float(self.cvss_score)
        return '{0}{1}{2}'.format(self.vendor.lower(), self.product.lower(),
                                  score_rev)


def print_exit(text, result):
    """
    Prints error message to stderr and exits with result code.
    """
    print(text, file=sys.stderr)
    sys.exit(result)


def get_bulletin_name(date=date.today()):
    """
    Return correct filename of a bulletin for a given date,
    which is published each Monday.
    """
    while (date.weekday() != 0):
        date = date - timedelta(days=1)
    return 'SB{0:%y}-{1:%j}'.format(date, date)


def get_bulletin_list(from_date=date.today(), to_date=date.today()):
    """
    Return a list of all filenames of bulletins to retrieve.
    """
    bulletin_list = []
    verboseprint('creating list of filenames from {0} to {1}'.
                 format(from_date, to_date))
    while (from_date <= to_date):
        bulletin_list.append(get_bulletin_name(from_date))
        from_date += timedelta(weeks=1)
    return bulletin_list


def retrieve_bulletin(filename, base_url, bulletin_name):
    """
    Return bulletin (either by HTTP or by file) as tree, or empty object
    if a bulletin couldn't be read.
    """
    result = False
    url = '{0}{1}'.format(base_url, bulletin_name)
    try:
        if (force or not os.path.isfile(filename)):
            verboseprint('trying to download {0}'.format(url))
            page = requests.get(url)
            if page.status_code == 200:
                tree = html.fromstring(page.text)
                result = check_title(tree)
                if result:
                    with open(filename, 'w') as f:
                        f.write(page.text.encode('utf-8'))
        else:
            verboseprint('reading {0} from disk'.format(filename))
            with open(filename, 'r') as f:
                tree = html.fromstring(f.read())
                result = check_title(tree)
        if result:
            return tree
        else:
            return None
    except requests.exceptions.ConnectionError as exception:
        print_exit('[-] Error connecting to website ({0})'.format(exception.strerror),
                   exception.errno)


def append_vulnerabilities(tree, vuln_type, vuln_list):
    """
    Append vulnerability from tree of vuln_type to vuln_list.
    """
    verboseprint('Adding {0} vulnerabilities'.format(vuln_type))
    vulns = tree.xpath('//table[@summary="{0} Vulnerabilities"]/tbody/tr'.
                       format(vuln_type))
    for vuln in vulns:
        vendor = vuln[0].text.split(' -- ')[0]
        product = vuln[0].text.split(' -- ')[1]
        description = vuln[1].text
        published = vuln[2].text
        cvss = vuln[4][0].text
        cvss_score = vuln[3][0].text
        source_info = vuln[4][0].text
        vuln_list.append(Vulnerability(vendor, product, description, published,
                                       cvss, cvss_score, source_info))


def check_title(tree):
    """
    Check whether the tree contains a vulnerability summary.
    """
    title = tree.xpath('//title/text()')[0].split(' | ')[0].replace('[\'', '')
    verboseprint('title: {0}'.format(title))
    response = re.search('^Vulnerability Summary', title)
    return response


def parse_arguments():
    """
    Parses command line arguments, exits on invalid values.
    """
    global cache
    global force
    global from_date
    from_date = None
    global to_date
    to_date = date.today()
    global verboseprint
    global quiet
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=textwrap.dedent('''\
Downloads and parses vulnerability summaries from the US-CERT website

Copyright (C) 2015 Peter Mosmans [Go Forward]
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.'''))
    parser.add_argument('-a', '--all', action='store_true',
                        help='retrieve all missing bulletin since 2010 (!)')
    parser.add_argument('-c', '--cache', default='cache',
                        help='name of cache directory')
    parser.add_argument('-f', '--force', action='store_true',
                        help='force download, ignore / overwrite cache')
    parser.add_argument('-l', '--low', action='store_true',
                        help='select low vulnerabilities as well')
    parser.add_argument('--quiet', action='store_true',
                        help='don\'t output parsed bulletin')
    parser.add_argument('--update', action='store_true',
                        help='retrieve all newest bulletin since last update')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='increase output verbosity')
    parser.add_argument('--year', action='store', nargs='?', default=0,
                        type=int,
                        help='retrieve all bulletins for a given year year')
    args = parser.parse_args()
    if args.verbose:
        def verboseprint(*args):
            print('# ', end='')
            for arg in args:
                print(arg, end='')
                print()
    else:
        verboseprint = lambda *a: None
    if (args.year is None) or (args.update):
        from_date = date(date.today().year, 1, 1)
    else:
        if ((args.year >= 2010) and (args.year <= date.today().year)):
            from_date = date(args.year, 1, 1)
            to_date = date(args.year, 12, 31)
    if args.all:
        from_date = date(2010, 1, 1)
    if from_date is None:
        from_date = to_date
    force = args.force
    cache = args.cache
    if cache:
        if not cache.endswith(os.path.sep):
            cache += os.path.sep
        if not os.path.exists(cache):
            verboseprint('creating {0}'.format(cache))
            os.makedirs(cache)
    if args.low:
        selection.append('Low')
    if args.quiet:
        quiet = True


def show_vulnerabilities(vuln_list):
    """Return a nicely formatted string of vulnerabilities from vuln_list"""
    for vuln in vuln_list:
        print('|{0}, {1}|{2}|{3}|{4}|{5}|'.format(vuln.vendor, vuln.product,
                                                  vuln.description,
                                                  vuln.published,
                                                  vuln.cvss_score, vuln.cvss))


def main():
    parse_arguments()
    vulnerabilities = []
    for bulletin_name in get_bulletin_list(from_date, to_date):
        filename = '{0}{1}.html'.format(cache, bulletin_name)
        tree = retrieve_bulletin(filename, base_url, bulletin_name)
        if not (tree is None):
            if not quiet:
                for vuln_type in selection:
                    append_vulnerabilities(tree, vuln_type, vulnerabilities)
                vulnerabilities = sorted(vulnerabilities,
                                         key=lambda x: x.sortname())
                show_vulnerabilities(vulnerabilities)
            sys.stdout.flush()


if __name__ == "__main__":
    main()
