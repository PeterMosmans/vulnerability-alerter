#!/usr/bin/env python

"""
Scrapes information from US-CERT and parses it into a formatted list of
HIGH and MEDIUM vulnerabilities

Copyright (C) 2015 Peter Mosmans [Go Forward]
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
"""

from __future__ import absolute_import
from __future__ import print_function

import argparse
from datetime import date, datetime, timedelta

import os.path
import re
import sys
import textwrap

from lxml import html
import requests


__author__ = "Peter Mosmans"
__copyright__ = "Copyright 2015, Go Forward"
__license__ = "GPLv3"
__version__ = "0.0.1"
__maintainer__ = "Peter Mosmans"
__contact__ = "support@go-forward.net"
__status__ = "Development"


BASE_URL = 'https://www.us-cert.gov/ncas/bulletins/'


class Vulnerability(object):
    """
    Encapsulates vulnerability.
    """

    def __init__(self, vendor, product, description, published, cvss,
                 cvss_score, source_info):
        self.vendor = vendor
        self.product = product
        self.description = description
        self.published = published
        self.cvss = cvss
        self.cvss_score = cvss_score
        self.source_info = source_info

    def sortname(self):
        # return 10 minus cvss_score
        score_rev = 10 - float(self.cvss_score)
        return '{0}{1}{2}'.format(self.vendor.lower(), self.product.lower(),
                                  score_rev)


def print_exit(text, result=-1):
    """
    Prints error message to stderr and exits with result code.
    """
    print(text, file=sys.stderr)
    sys.exit(result)


def get_bulletin_name(date=date.today()):
    """
    Return correct filename of a bulletin for a given date,
    which is published each Monday.
    """
    while date.weekday():
        date = date - timedelta(days=1)
    return 'SB{0:%y}-{1:%j}'.format(date, date)


def get_bulletin_list(options):
    """
    Return a list of all filenames of bulletins to retrieve.
    """
    bulletin_list = []
    from_date = options['from_date']
    print_status('creating list of filenames from {0} to {1}'.
                 format(from_date, options['to_date']), options)
    while from_date <= (options['to_date'] + timedelta(days=6)):
        bulletin_list.append(get_bulletin_name(from_date))
        from_date += timedelta(weeks=1)
    return bulletin_list


def retrieve_bulletin(filename, bulletin_name, options):
    """
    Return bulletin (either by HTTP or by file) as tree, or empty object
    if a bulletin couldn't be read.
    """
    tree = None
    date_string = False
    url = '{0}{1}'.format(BASE_URL, bulletin_name)
    try:
        if options['force'] or not os.path.isfile(filename):
            print_status('trying to download {0}'.format(url), options)
            page = requests.get(url)
            if page.status_code == 200:
                tree = html.fromstring(page.text)
                date_string = check_title(tree, options)
                if date_string:
                    with open(filename, 'w') as html_page:
                        html_page.write(page.text.encode('utf-8'))
            else:
                print_line('Received status code {0}'.format(page.status_code),
                           True)
        else:
            print_status('reading {0} from disk'.format(filename), options)
            with open(filename, 'r') as html_page:
                tree = html.fromstring(html_page.read())
                date_string = check_title(tree, options)
        if not date_string:
            return None
        if options['query']:
            if options['query'] in date_string:
                print('DATE: ' + date_string)
                return tree
            else:
                return None
        else:
            return tree
    except requests.exceptions.ConnectionError as exception:
        print_error('[-] Error connecting to website ({0})'.
                    format(exception.strerror),
                    exception.errno)


def append_vulnerabilities(tree, vuln_type, vuln_list, options):
    """
    Append vulnerability from tree of vuln_type to vuln_list.
    """
    print_status('Adding {0} vulnerabilities'.format(vuln_type), options)
    vulns = tree.xpath('//table[@summary="{0} Vulnerabilities"]/tbody/tr'.
                       format(vuln_type))
    for vuln in vulns:
        vendor = ''
        product = ''
        if vuln[0].text:
            if '--' in vuln[0].text:
                vendor = vuln[0].text.split(' -- ')[0]
                product = vuln[0].text.split(' -- ')[1]
            else:
                vendor = vuln[0].text
        description = vuln[1].text
        published = vuln[2].text
        cvss = vuln[4][0].text
        try:
            cvss_score = vuln[3][0].text
        except IndexError:
            cvss_score = '0'
        source_info = vuln[4][0].text
        vuln_list.append(Vulnerability(vendor, product, description, published,
                                       cvss, cvss_score, source_info))


def check_title(tree, options):
    """
    Check whether the tree contains a vulnerability summary.
    Returns the date in American string format
    """
    title = tree.findtext('.//title').split(' | ')[0].replace('[\'', '')
    response = re.search('Vulnerability Summary for the Week of (\w+\s[0-9]{1,2}\,\s[0-9]{4})', title)
    if response and response.groups > 1:
        print_status('date: {0}'.format(response.group(1)), options)
        return response.group(1)
    else:
        return False


def parse_arguments():
    """
    Parses command line arguments, exits on invalid values.
    """
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=textwrap.dedent('''\
Downloads and parses vulnerability summaries from the US-CERT website

Copyright (C) 2015-2016 Peter Mosmans [Go Forward]
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.'''))
    parser.add_argument('-a', '--all', action='store_true',
                        help='retrieve all missing bulletin since 2010 (!)')
    parser.add_argument('-b', '--bulletin', action='store', type=str,
                        help='retrieve a specific bulletin')
    parser.add_argument('-c', '--cache', default='cache',
                        help='name of cache directory')
    parser.add_argument('-f', '--force', action='store_true',
                        help='force download, ignore / overwrite cache')
    parser.add_argument('--from-date', action='store',
                        help='starting date (dd-mm-YYYY)')
    parser.add_argument('-l', '--low', action='store_true',
                        help='select low vulnerabilities as well')
    parser.add_argument('--quiet', action='store_true',
                        help='don\'t output parsed bulletin')
    parser.add_argument('--query', action='store',
                        help='specify a query for the title')
    parser.add_argument('--update', action='store_true',
                        help='retrieve all newest bulletin since last update')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='increase output verbosity')
    parser.add_argument('--year', action='store', nargs='?', default=0,
                        type=int,
                        help='retrieve all bulletins for a given year year')
    return vars(parser.parse_args())


def preflight_checks(options):
    """
    Prepare everything for a smooth ride.
    """
    if not options['cache'].endswith(os.path.sep):
        options['cache'] += os.path.sep
    if not os.path.exists(options['cache']):
        print_status('creating {0}'.format(options['cache']), options)
        os.makedirs(options['cache'])
    try:
        if options['from_date']:
            options['from_date'] = datetime.strptime(options['from_date'],
                                                     '%d-%m-%Y').date()
    except ValueError:
        print_exit('dates must be in the form dd-mm-YYYY')
    options['to_date'] = date.today()
    options['selection'] = ['High', 'Medium']
    if not options['from_date'] and ('year' not in options or (options['update'])):
        options['from_date'] = date(date.today().year, 1, 1)
    else:
        if options['year'] >= 2010 and options['year'] <= date.today().year:
            options['from_date'] = date(options['year'], 1, 1)
            options['to_date'] = date(options['year'], 12, 31)
    if options['all']:
        options['from_date'] = date(2010, 1, 1)
    if options['from_date'] is None:
        options['from_date'] = options['to_date']
    if options['low']:
        options['selection'].append('Low')
    return options


def print_error(text, result=False):
    """
    Prints error message
    When @result, exits with result.
    """
    if len(text):
        print_line('[-] ' + text, True)
    if result:
        sys.exit(result)


def print_line(text, error=False):
    """
    Prints text, and flushes stdout and stdin.
    When @error, prints text to stderr instead of stdout.
    """
    if not error:
        print(text)
    else:
        print(text, file=sys.stderr)
    sys.stdout.flush()
    sys.stderr.flush()


def print_status(text, options=False):
    """
    Prints status message if options array is given and contains 'verbose'.
    """
    if options and options['verbose']:
        print_line('[*] ' + text)


def show_vulnerabilities(vuln_list):
    """Return a nicely formatted string of vulnerabilities from vuln_list"""
    for vuln in vuln_list:
        print('|{0}, {1}|{2}|{3}|{4}|{5}|'.format(vuln.vendor, vuln.product,
                                                  vuln.description,
                                                  vuln.published,
                                                  vuln.cvss_score, vuln.cvss))


def main():
    """
    The main loop.
    """
    options = preflight_checks(parse_arguments())
    vulnerabilities = []
    for bulletin_name in get_bulletin_list(options):
        if options['bulletin']:
            bulletin_name = options['bulletin']
        filename = '{0}{1}.html'.format(options['cache'], bulletin_name)
        tree = retrieve_bulletin(filename, bulletin_name, options)
        if tree is not None and not options['quiet']:
            for vuln_type in options['selection']:
                append_vulnerabilities(tree, vuln_type, vulnerabilities,
                                       options)
    vulnerabilities = sorted(vulnerabilities,
                                 key=lambda x: x.sortname())
    show_vulnerabilities(vulnerabilities)
    sys.stdout.flush()


if __name__ == "__main__":
    main()
