#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""Scrape information from US-CERT and parse it into a formatted list.

Copyright (C) 2015-2017 Peter Mosmans [Go Forward]
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
"""

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

import argparse
from datetime import date, datetime, timedelta
import io
import logging
import os.path
import re
import sys
import textwrap

try:
    from lxml import etree, html
    import requests
except ImportError as exception:
    print('[-] This script needs the lxml and requests library: {0}'.
          format(exception), file=sys.stderr)
    print("Install lxml with: sudo pip install lxml", file=sys.stderr)
    print("Install requests with: sudo pip install requests", file=sys.stderr)
    sys.exit(-1)

__author__ = "Peter Mosmans"
__copyright__ = "Copyright 2015-2019, Go Forward"
__license__ = "GPLv3"
__version__ = "1.2.0"
__maintainer__ = "Peter Mosmans"
__contact__ = "support@go-forward.net"


BASE_URL = 'https://www.us-cert.gov/ncas/bulletins/'


class Vulnerability(object):
    """Encapsulate vulnerability."""

    def __init__(self, vendor, product, description, published, cvss,
                 cvss_score, source_info):
        self.vendor = vendor
        self.product = product
        self.description = description
        self.published = published
        self.cvss = cvss
        self.cvss_score = float(cvss_score)
        self.source_info = source_info

    def sortname(self):
        """Sort vulnerabilities based on CVSS score."""
        # return 10 minus cvss_score
        score_rev = 10 - float(self.cvss_score)
        return '{0}{1}{2}'.format(self.vendor.lower(), self.product.lower(),
                                  score_rev)


def get_bulletin_name(date_object=date.today()):
    """
    Return correct filename of a bulletin for a given date,
    which is published each Monday.
    """
    while date_object.weekday():
        date_object = date_object - timedelta(days=1)
    return 'SB{0:%y}-{1:%j}'.format(date_object, date_object)


def get_bulletin_list(options):
    """
    Return a list of all filenames of bulletins to retrieve.
    """
    bulletin_list = []
    from_date = options['from_date']
    logging.debug('Creating list of filenames from %s to %s', from_date,
                  options['to_date'])
    while from_date <= (options['to_date'] + timedelta(days=3)):
        bulletin_list.append(get_bulletin_name(from_date))
        from_date += timedelta(weeks=1)
    logging.debug('Created the following names: %s', bulletin_list)
    return bulletin_list


def retrieve_page(url):
    """
    Parse given url as tree and return the tree and text.

    Return empty object if the url couldn't be parsed as a bulletin.
    """
    logging.debug('Trying to download ' + url)
    page = requests.get(url)
    logging.debug('Received status code %s', page.status_code)
    if page.status_code == 200:
        tree = html.fromstring(page.text)
        if check_title(tree):
            return tree, page.text
    return None, None


def retrieve_bulletin(filename, bulletin_name, options):
    """
    Return bulletin (either by HTTP or by file) as tree, or empty object
    if a bulletin couldn't be read.
    """
    tree = None
    base_url = '{0}{1}'.format(BASE_URL, bulletin_name)
    suffices = ['', '-0', '-1', '-2']
    try:
        if options['force'] or not os.path.isfile(filename):
            for suffix in suffices:
                tree, text = retrieve_page(base_url + suffix)
                if tree is not None:
                    break
            if tree is not None:
                logging.debug('Writing bulletin to cache')
                with io.open(filename, 'w', encoding='utf-8') as html_page:
                    html_page.write(text)
        else:
            logging.debug('Reading %s from disk', filename)
            with io.open(filename, 'r', encoding='utf-8') as html_page:
                tree = html.fromstring(html_page.read())
        date_object = check_title(tree)
        if date_object and (date_object > options['from_date']) or \
           options['latest']:
            return tree
    except requests.exceptions.ConnectionError as exception:
        logging.error('Error connecting to website (%s)', exception.strerror)
        sys.exit(exception.errno)
    except etree.ParserError as exception:
        logging.error('Could not parse document (%s)', exception)
    return None


def append_vulnerabilities(tree, vuln_type):
    """Return list of vulnerabilities from tree of vuln_type."""
    logging.debug('Adding %s vulnerabilities', vuln_type)
    if vuln_type in ['High', 'Medium', 'Low']:
        title = '{0} Vulnerabilities'.format(vuln_type)
    else:
        title = 'Severity Not Yet Assigned'
    vulnerabilities = []
    for vuln in tree.xpath('//table[@summary="{0}"]/tbody/tr'.
                           format(title)):
        vendor = ''
        product = ''
        if len(vuln) and vuln[0].text:
            try:
                vendor, product = vuln[0].text.split(' -- ')
            except ValueError:
                vendor = vuln[0].text
            description = vuln[1].text
            published = vuln[2].text
            try:
                cvss = vuln[4][0].text
                cvss_score = vuln[3][0].text
                source_info = vuln[4][0].text
            except IndexError:
                cvss = ""
                cvss_score = "0"
                source_info = "unknown"
            vulnerabilities.append(Vulnerability(vendor, product, description,
                                                 published, cvss, cvss_score,
                                                 source_info))
    return vulnerabilities


def check_title(tree):
    """
    Check whether the tree contains a vulnerability summary.
    Returns a date object if successful.
    """
    try:
        title = tree.xpath('//title/text()')[0].split(' | ')[0].replace('[\'',
                                                                        '')
    except AttributeError:
        title = ''
    logging.debug('Extracted title %s', title)
    response = re.search(r'Vulnerability Summary for the Week of (\w+\s[0-9]{1,2}\,\s[0-9]{4})',
                         title)
    if response and response.groups:
        date_object = datetime.strptime(response.group(1), '%B %d, %Y')
        logging.debug('Read date: %s', date_object)
        return date_object.date()
    logging.debug('Not recognized as a valid bulletin')
    return False


def parse_arguments():
    """
    Parses command line arguments, exits on invalid values.
    """
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=textwrap.dedent('''\
Downloads and parses vulnerability summaries from the US-CERT website

Copyright (C) 2015-2017 Peter Mosmans [Go Forward]
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.'''))
    parser.add_argument('-a', '--all', action='store_true',
                        help='retrieve all missing bulletin since 2010 (!)')
    parser.add_argument('-b', '--bulletin', action='store', type=str,
                        help='retrieve a specific bulletin')
    parser.add_argument('-c', '--cache', default='cache',
                        help='name of cache directory')
    parser.add_argument('-f', '--force', action='store_true',
                        help='force download, ignore / overwrite cache')
    parser.add_argument('--from-date', action='store',
                        help='starting date (dd-mm-YYYY)')
    parser.add_argument('-l', '--low', action='store_true',
                        help='select low vulnerabilities as well')
    parser.add_argument('--latest', action='store_true',
                        help='show latest bulletin')
    parser.add_argument('--quiet', action='store_true',
                        help="don't output parsed bulletin")
    parser.add_argument('--query', action='store',
                        help='specify a query for the title')
    parser.add_argument('--unassigned', action='store_true',
                        help='show vulnerabilities having no CVSS score assigned')
    parser.add_argument('--update', action='store_true',
                        help='retrieve all newest bulletin since last update')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='increase output verbosity')
    parser.add_argument('--year', action='store', nargs='?', default=0,
                        type=int,
                        help='retrieve all bulletins for a given year year')
    return vars(parser.parse_args())


def preflight_checks(options):
    """
    Prepare everything for a smooth ride.
    """
    if not options['cache'].endswith(os.path.sep):
        options['cache'] += os.path.sep
    if not os.path.exists(options['cache']):
        logging.debug('Creating %s', options['cache'])
        os.makedirs(options['cache'])
    try:
        if options['from_date']:
            options['from_date'] = datetime.strptime(options['from_date'],
                                                     '%d-%m-%Y').date()
    except ValueError:
        logging.error('Dates must be in the form dd-mm-YYYY')
        sys.exit(-1)
    options['to_date'] = date.today() + timedelta(days=2)
    options['selection'] = ['High', 'Medium']
    if not options['from_date'] and ('year' not in options or (options['update'])):
        options['from_date'] = date(date.today().year, 1, 1)
    else:
        if options['year'] >= 2010 and options['year'] <= date.today().year:
            options['from_date'] = date(options['year'], 1, 1)
            options['to_date'] = date(options['year'], 12, 31)
    if options['all']:
        options['from_date'] = date(2010, 1, 1)
    if options['from_date'] is None:
        options['from_date'] = options['to_date'] - timedelta(days=7)
    if options['low']:
        options['selection'].append('Low')
    if options['unassigned']:
        options['selection'].append('Unassigned')
    logging.debug(options)
    return options


def setup_logging(options):
    """
    Set up loghandlers according to options.
    """
    # DEBUG = verbose status messages
    # INFO = status messages and logfiles
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)
    console = logging.StreamHandler(stream=sys.stdout)
    console.setFormatter(logging.Formatter('%(asctime)s %(message)s',
                                           datefmt='%H:%M:%S'))
    if options['verbose']:
        console.setLevel(logging.DEBUG)
    else:
        console.setLevel(logging.INFO)
    logger.addHandler(console)
    # make sure requests library is, erm, less verbose
    logging.getLogger('requests.packages.urllib3.connectionpool').setLevel(logging.ERROR)


def show_vulnerabilities(vuln_list):
    """Return a nicely formatted string of vulnerabilities from vuln_list"""
    for vuln in vuln_list:
        print('|{0}, {1}|{2}|{3}|{4}|{5}|'.format(vuln.vendor, vuln.product,
                                                  vuln.description,
                                                  vuln.published,
                                                  vuln.cvss_score, vuln.cvss))


def main():
    """
    The main loop.
    """
    options = parse_arguments()
    setup_logging(options)
    preflight_checks(options)
    vulnerabilities = []
    for bulletin_name in get_bulletin_list(options):
        if options['bulletin']:
            bulletin_name = options['bulletin']
        filename = '{0}{1}.html'.format(options['cache'], bulletin_name)
        tree = retrieve_bulletin(filename, bulletin_name, options)
        if tree is not None and not options['quiet']:
            latest = []
            for vuln_type in options['selection']:
                latest += append_vulnerabilities(tree, vuln_type)
            vulnerabilities += latest
    if options['latest']:
        vulnerabilities = latest
    vulnerabilities = sorted(vulnerabilities,
                             key=lambda x: x.sortname())
    show_vulnerabilities(vulnerabilities)


if __name__ == "__main__":
    main()
